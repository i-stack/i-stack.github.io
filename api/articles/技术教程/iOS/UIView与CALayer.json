{"title":"UIView与CALayer","slug":"技术教程/iOS/UIView与CALayer","date":"2022-02-05T03:27:13.000Z","updated":"2023-05-05T14:55:02.791Z","comments":true,"path":"api/articles/技术教程/iOS/UIView与CALayer.json","excerpt":null,"covers":["/posts/aae2988/UIViewseaNeedsDieplay.png"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"UIView-UIResponse\"><a href=\"#UIView-UIResponse\" class=\"headerlink\" title=\"UIView: UIResponse\"></a><code>UIView: UIResponse</code></h2><p>管理屏幕上矩形区域内容的对象；</p>\n<p>负责渲染区域的内容，并且响应该区域内发生的触摸事件；</p>\n<p>UIView职责：绘制与动画、布局与子视图管理、事件处理。</p>\n<h2 id=\"CALayer：-NSObject\"><a href=\"#CALayer：-NSObject\" class=\"headerlink\" title=\"CALayer： NSObject\"></a><code>CALayer： NSObject</code></h2><p>管理内部的可视内容，负责渲染和动画；</p>\n<p>圆角、阴影、边框等特效都需要使用layer属性设置；</p>\n<h2 id=\"￼UIView-的绘制流程\"><a href=\"#￼UIView-的绘制流程\" class=\"headerlink\" title=\"￼UIView 的绘制流程\"></a>￼<code>UIView</code> 的绘制流程</h2><p><img src=\"/posts/aae2988/UIViewseaNeedsDieplay.png\"></p>\n<p>1、每一个 <code>UIView</code> 都有一个 <code>layer</code> ，每一个 <code>layer</code> 都有个 <code>content</code> ，这个 <code>content</code> 指向的是一块缓存，叫做 <code>backing store</code>。</p>\n<p>2、<code>UIView</code> 的绘制和渲染是两个过程，当 <code>UIView</code> 被绘制时，<code>CPU</code> 执行 <code>drawRect</code> ，通过 <code>context</code> 将数据写入 <code>backing store</code>。</p>\n<p>3、当 <code>backing store</code> 写完后，通过 <code>render server</code> 交给 <code>GPU</code> 去渲染，将 <code>backing store</code> 中的 <code>bitmap</code> 数据显示在屏幕上。</p>\n<h2 id=\"￼UIView-绘制渲染机制和-Runloop-的关系\"><a href=\"#￼UIView-绘制渲染机制和-Runloop-的关系\" class=\"headerlink\" title=\"￼UIView 绘制渲染机制和 Runloop 的关系\"></a>￼<code>UIView</code> 绘制渲染机制和 <code>Runloop</code> 的关系</h2><p>操作UI时，比如：改变frame、更新UIView/UILayer的层次结构、手动调用UIView/UILayer的setNeedsLayout/setNeedsDisplay方法后，此时UIView/UILayer被标记为待处理。</p>\n<h3 id=\"setNeedsLayout\"><a href=\"#setNeedsLayout\" class=\"headerlink\" title=\"setNeedsLayout\"></a>setNeedsLayout</h3><p>调用该方法：告诉App在更新周内，布局及重绘当前视图及子视图</p>\n<p>1、该方法是异步操作且必须在主线程中调用；</p>\n<p>2、调用该方法不能精确的控制试图约束更新时间，因为该方法调用完成会立即返回；</p>\n<p>3、该方法可以将多个布局更新放在一个更新周期中更新。</p>\n<h3 id=\"layoutIfNeeded\"><a href=\"#layoutIfNeeded\" class=\"headerlink\" title=\"layoutIfNeeded\"></a>layoutIfNeeded</h3><p>调用该方法：告诉App立即布局及重绘当前视图及子视图，不需要等待更新周期</p>\n<p>该方法是同步操作，布局更新和视图重绘已在该方法调用完成之前全部更新。</p>\n<h3 id=\"layoutSubviews\"><a href=\"#layoutSubviews\" class=\"headerlink\" title=\"layoutSubviews\"></a>layoutSubviews</h3><p>1、该方法会根据你设置的约束来确定子视图的位置和尺寸；</p>\n<p>2、当子视图执行更加精细的布局时，可以重写该方法；</p>\n<p>3、只有当子视图的自动调整（autoresizing）和基于约束的行为不能提供所需的行为时，才应该重写此方法；</p>\n<p>4、不要直接调用该方法，如果你想强制更新布局，可以调用 <code>setNeedsLayout()</code> 方法，如果想立刻更新布局，可以调用 <code>layoutIfNeeded()</code> 方法；</p>\n","more":"<h2 id=\"UIView-UIResponse\"><a href=\"#UIView-UIResponse\" class=\"headerlink\" title=\"UIView: UIResponse\"></a><code>UIView: UIResponse</code></h2><p>管理屏幕上矩形区域内容的对象；</p>\n<p>负责渲染区域的内容，并且响应该区域内发生的触摸事件；</p>\n<p>UIView职责：绘制与动画、布局与子视图管理、事件处理。</p>\n<h2 id=\"CALayer：-NSObject\"><a href=\"#CALayer：-NSObject\" class=\"headerlink\" title=\"CALayer： NSObject\"></a><code>CALayer： NSObject</code></h2><p>管理内部的可视内容，负责渲染和动画；</p>\n<p>圆角、阴影、边框等特效都需要使用layer属性设置；</p>\n<h2 id=\"￼UIView-的绘制流程\"><a href=\"#￼UIView-的绘制流程\" class=\"headerlink\" title=\"￼UIView 的绘制流程\"></a>￼<code>UIView</code> 的绘制流程</h2><p><img src=\"/posts/aae2988/UIViewseaNeedsDieplay.png\"></p>\n<p>1、每一个 <code>UIView</code> 都有一个 <code>layer</code> ，每一个 <code>layer</code> 都有个 <code>content</code> ，这个 <code>content</code> 指向的是一块缓存，叫做 <code>backing store</code>。</p>\n<p>2、<code>UIView</code> 的绘制和渲染是两个过程，当 <code>UIView</code> 被绘制时，<code>CPU</code> 执行 <code>drawRect</code> ，通过 <code>context</code> 将数据写入 <code>backing store</code>。</p>\n<p>3、当 <code>backing store</code> 写完后，通过 <code>render server</code> 交给 <code>GPU</code> 去渲染，将 <code>backing store</code> 中的 <code>bitmap</code> 数据显示在屏幕上。</p>\n<h2 id=\"￼UIView-绘制渲染机制和-Runloop-的关系\"><a href=\"#￼UIView-绘制渲染机制和-Runloop-的关系\" class=\"headerlink\" title=\"￼UIView 绘制渲染机制和 Runloop 的关系\"></a>￼<code>UIView</code> 绘制渲染机制和 <code>Runloop</code> 的关系</h2><p>操作UI时，比如：改变frame、更新UIView&#x2F;UILayer的层次结构、手动调用UIView&#x2F;UILayer的setNeedsLayout&#x2F;setNeedsDisplay方法后，此时UIView&#x2F;UILayer被标记为待处理。</p>\n<h3 id=\"setNeedsLayout\"><a href=\"#setNeedsLayout\" class=\"headerlink\" title=\"setNeedsLayout\"></a>setNeedsLayout</h3><p>调用该方法：告诉App在更新周内，布局及重绘当前视图及子视图</p>\n<p>1、该方法是异步操作且必须在主线程中调用；</p>\n<p>2、调用该方法不能精确的控制试图约束更新时间，因为该方法调用完成会立即返回；</p>\n<p>3、该方法可以将多个布局更新放在一个更新周期中更新。</p>\n<h3 id=\"layoutIfNeeded\"><a href=\"#layoutIfNeeded\" class=\"headerlink\" title=\"layoutIfNeeded\"></a>layoutIfNeeded</h3><p>调用该方法：告诉App立即布局及重绘当前视图及子视图，不需要等待更新周期</p>\n<p>该方法是同步操作，布局更新和视图重绘已在该方法调用完成之前全部更新。</p>\n<h3 id=\"layoutSubviews\"><a href=\"#layoutSubviews\" class=\"headerlink\" title=\"layoutSubviews\"></a>layoutSubviews</h3><p>1、该方法会根据你设置的约束来确定子视图的位置和尺寸；</p>\n<p>2、当子视图执行更加精细的布局时，可以重写该方法；</p>\n<p>3、只有当子视图的自动调整（autoresizing）和基于约束的行为不能提供所需的行为时，才应该重写此方法；</p>\n<p>4、不要直接调用该方法，如果你想强制更新布局，可以调用 <code>setNeedsLayout()</code> 方法，如果想立刻更新布局，可以调用 <code>layoutIfNeeded()</code> 方法；</p>\n","abbrlink":"aae2988","categories":[{"name":"技术教程","path":"api/categories/技术教程.json"}],"tags":[{"name":"iOS","path":"api/tags/iOS.json"}]}