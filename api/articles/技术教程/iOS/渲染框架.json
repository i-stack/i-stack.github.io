{"title":"渲染框架","slug":"技术教程/iOS/渲染框架","date":"2022-02-01T03:03:15.000Z","updated":"2023-08-10T16:08:13.073Z","comments":false,"path":"api/articles/技术教程/iOS/渲染框架.json","excerpt":null,"covers":null,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Core-Graphics\"><a href=\"#Core-Graphics\" class=\"headerlink\" title=\"Core Graphics\"></a>Core Graphics</h2><p><code>Core Graphics</code> 是一个强大的二维图像绘制引擎，是 <code>iOS</code> 的核心图形库，常用的比如 <code>CGRect</code> 就定义在这个框架下。</p>\n<h2 id=\"Core-Animation\"><a href=\"#Core-Animation\" class=\"headerlink\" title=\"Core Animation\"></a>Core Animation</h2><p>1、在 <code>iOS</code> 上，几乎所有的东西都是通过 <code>Core Animation</code> 绘制出来，主要用于：渲染、构建和实现动画；</p>\n<p>2、<code>Core Animation</code> 尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的&nbsp;<code>CALayer</code>，并且被存储为树状层级结构；</p>\n<p>3、<code>CALayer</code> 是屏幕显示的基础，在 <code>CALayer.h</code> 中，<code>CALayer</code> 有一个 <code>contents</code> 属性保存了设备流水线渲染好的位图 <code>bitmap</code>（通常也被称为&nbsp;backing store），而当设备屏幕进行刷新时，会从 <code>CALayer</code> 中读取生成好的 <code>bitmap</code>，进而呈现到屏幕上；</p>\n<p>4、所以每次渲染时，<code>Core Animation</code> 会触发调用&nbsp;<code>drawRect:</code>&nbsp;方法，使用存储好的 <code>bitmap</code> 进行新一轮的展示。</p>\n<h2 id=\"Core-Animation-渲染流程\"><a href=\"#Core-Animation-渲染流程\" class=\"headerlink\" title=\"Core Animation 渲染流程\"></a>Core Animation 渲染流程</h2><p>![](Pasted Graphic.png)</p>\n<h3 id=\"Handle-Events\"><a href=\"#Handle-Events\" class=\"headerlink\" title=\"Handle Events\"></a>Handle Events</h3><p>这个过程中会先处理点击事件，有可能会需要改变页面的布局和界面层次。</p>\n<h3 id=\"Commit-Transaction\"><a href=\"#Commit-Transaction\" class=\"headerlink\" title=\"Commit Transaction\"></a>Commit Transaction</h3><p>此时 app 会通过 CPU 处理显示内容的前置计算，比如布局计算、图片解码等任务，之后将计算好的图层进行打包发给&nbsp;Render Server。</p>\n<p>Layout ：构建 UI， 布局，文本计算等；具体步骤包括：</p>\n<p>调用重载 layoutSubviews方法；</p>\n<p>创建视图，并通过addSubview方法添加子视图</p>\n<p>计算视图布局，即所有的Layout Constraint</p>\n<p>Display ：视图绘制</p>\n<p>这个阶段主要是Core Graphics进行视图绘制，不是真正的现实，而是得到图元数据。</p>\n<p>如果重写drawRect:方法，会在drawRect:方法中绘制得到bitmap数据，实现自定义视图的绘制；</p>\n<p>重写drawRect:方法，绘制过程将从GPU转移到CPU，导致一定的效率损失，这个过程会额外使用CPU和内存，容易造成CPU卡顿或者内存警告。</p>\n<p>Prepare ：附加步骤</p>\n<p>主要做图片解码和转换。</p>\n<p>Commit ：将 layer 递归打包发送</p>\n<p>递归将图层打包发送到Render Server。</p>\n<p>如果图层树过于复杂，commit开销大，这就是减少视图层级，降低图层树复杂度的原因。</p>\n<h3 id=\"Decode\"><a href=\"#Decode\" class=\"headerlink\" title=\"Decode\"></a>Decode</h3><p>打包好的图层被传输到&nbsp;Render Server&nbsp;之后，首先会进行解码。完成解码之后需要等待下一个 RunLoop 才会执行下一步&nbsp;Draw Calls。</p>\n<h3 id=\"Draw-Calls\"><a href=\"#Draw-Calls\" class=\"headerlink\" title=\"Draw Calls\"></a>Draw Calls</h3><p>解码完成后，Core Animation 会调用下层渲染框架（比如 OpenGL 或者 Metal）的方法进行绘制，进而调用到 GPU。</p>\n<h3 id=\"Render-Server\"><a href=\"#Render-Server\" class=\"headerlink\" title=\"Render Server\"></a>Render Server</h3><p>这一阶段主要由 GPU 进行渲染，通常是OpneGL或者Metal。</p>\n<p>将数据反序列化得到图层数；</p>\n<p>根据图层树的图层顺序、RGBA值、图层 frame 等过滤掉图层中被遮挡的部分；</p>\n<p>将图层树转为渲染树提交给 OpenGL / Metal；</p>\n<p>OpenGL / Metal 生成绘制命令，等待 V-Sync 信号到来，随后提交到命令缓冲区 Command Buffer 供 GPU 读取执行。</p>\n<h3 id=\"Display\"><a href=\"#Display\" class=\"headerlink\" title=\"Display\"></a>Display</h3><p>显示阶段，需要等&nbsp;render&nbsp;结束的下一个 RunLoop 触发显示。</p>\n<h2 id=\"Core-Image\"><a href=\"#Core-Image\" class=\"headerlink\" title=\"Core Image\"></a>Core Image</h2><p>Core Image 是一个高性能的图像处理分析的框架，它拥有一系列现成的图像滤镜，能对已存在的图像进行高效的处理。</p>\n<h2 id=\"Metal\"><a href=\"#Metal\" class=\"headerlink\" title=\"Metal\"></a>Metal</h2><p>Metal 类似于 OpenGL ES，也是一套第三方标准，具体实现由苹果实现。Core Animation、Core Image、SceneKit、SpriteKit 等等渲染框架都是构建于 Metal 之上的。</p>\n","more":"<h2 id=\"Core-Graphics\"><a href=\"#Core-Graphics\" class=\"headerlink\" title=\"Core Graphics\"></a>Core Graphics</h2><p><code>Core Graphics</code> 是一个强大的二维图像绘制引擎，是 <code>iOS</code> 的核心图形库，常用的比如 <code>CGRect</code> 就定义在这个框架下。</p>\n<h2 id=\"Core-Animation\"><a href=\"#Core-Animation\" class=\"headerlink\" title=\"Core Animation\"></a>Core Animation</h2><p>1、在 <code>iOS</code> 上，几乎所有的东西都是通过 <code>Core Animation</code> 绘制出来，主要用于：渲染、构建和实现动画；</p>\n<p>2、<code>Core Animation</code> 尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的 <code>CALayer</code>，并且被存储为树状层级结构；</p>\n<p>3、<code>CALayer</code> 是屏幕显示的基础，在 <code>CALayer.h</code> 中，<code>CALayer</code> 有一个 <code>contents</code> 属性保存了设备流水线渲染好的位图 <code>bitmap</code>（通常也被称为 backing store），而当设备屏幕进行刷新时，会从 <code>CALayer</code> 中读取生成好的 <code>bitmap</code>，进而呈现到屏幕上；</p>\n<p>4、所以每次渲染时，<code>Core Animation</code> 会触发调用 <code>drawRect:</code> 方法，使用存储好的 <code>bitmap</code> 进行新一轮的展示。</p>\n<h2 id=\"Core-Animation-渲染流程\"><a href=\"#Core-Animation-渲染流程\" class=\"headerlink\" title=\"Core Animation 渲染流程\"></a>Core Animation 渲染流程</h2><p>![](Pasted Graphic.png)</p>\n<h3 id=\"Handle-Events\"><a href=\"#Handle-Events\" class=\"headerlink\" title=\"Handle Events\"></a>Handle Events</h3><p>这个过程中会先处理点击事件，有可能会需要改变页面的布局和界面层次。</p>\n<h3 id=\"Commit-Transaction\"><a href=\"#Commit-Transaction\" class=\"headerlink\" title=\"Commit Transaction\"></a>Commit Transaction</h3><p>此时 app 会通过 CPU 处理显示内容的前置计算，比如布局计算、图片解码等任务，之后将计算好的图层进行打包发给 Render Server。</p>\n<p>Layout ：构建 UI， 布局，文本计算等；具体步骤包括：</p>\n<p>调用重载 layoutSubviews方法；</p>\n<p>创建视图，并通过addSubview方法添加子视图</p>\n<p>计算视图布局，即所有的Layout Constraint</p>\n<p>Display ：视图绘制</p>\n<p>这个阶段主要是Core Graphics进行视图绘制，不是真正的现实，而是得到图元数据。</p>\n<p>如果重写drawRect:方法，会在drawRect:方法中绘制得到bitmap数据，实现自定义视图的绘制；</p>\n<p>重写drawRect:方法，绘制过程将从GPU转移到CPU，导致一定的效率损失，这个过程会额外使用CPU和内存，容易造成CPU卡顿或者内存警告。</p>\n<p>Prepare ：附加步骤</p>\n<p>主要做图片解码和转换。</p>\n<p>Commit ：将 layer 递归打包发送</p>\n<p>递归将图层打包发送到Render Server。</p>\n<p>如果图层树过于复杂，commit开销大，这就是减少视图层级，降低图层树复杂度的原因。</p>\n<h3 id=\"Decode\"><a href=\"#Decode\" class=\"headerlink\" title=\"Decode\"></a>Decode</h3><p>打包好的图层被传输到 Render Server 之后，首先会进行解码。完成解码之后需要等待下一个 RunLoop 才会执行下一步 Draw Calls。</p>\n<h3 id=\"Draw-Calls\"><a href=\"#Draw-Calls\" class=\"headerlink\" title=\"Draw Calls\"></a>Draw Calls</h3><p>解码完成后，Core Animation 会调用下层渲染框架（比如 OpenGL 或者 Metal）的方法进行绘制，进而调用到 GPU。</p>\n<h3 id=\"Render-Server\"><a href=\"#Render-Server\" class=\"headerlink\" title=\"Render Server\"></a>Render Server</h3><p>这一阶段主要由 GPU 进行渲染，通常是OpneGL或者Metal。</p>\n<p>将数据反序列化得到图层数；</p>\n<p>根据图层树的图层顺序、RGBA值、图层 frame 等过滤掉图层中被遮挡的部分；</p>\n<p>将图层树转为渲染树提交给 OpenGL &#x2F; Metal；</p>\n<p>OpenGL &#x2F; Metal 生成绘制命令，等待 V-Sync 信号到来，随后提交到命令缓冲区 Command Buffer 供 GPU 读取执行。</p>\n<h3 id=\"Display\"><a href=\"#Display\" class=\"headerlink\" title=\"Display\"></a>Display</h3><p>显示阶段，需要等 render 结束的下一个 RunLoop 触发显示。</p>\n<h2 id=\"Core-Image\"><a href=\"#Core-Image\" class=\"headerlink\" title=\"Core Image\"></a>Core Image</h2><p>Core Image 是一个高性能的图像处理分析的框架，它拥有一系列现成的图像滤镜，能对已存在的图像进行高效的处理。</p>\n<h2 id=\"Metal\"><a href=\"#Metal\" class=\"headerlink\" title=\"Metal\"></a>Metal</h2><p>Metal 类似于 OpenGL ES，也是一套第三方标准，具体实现由苹果实现。Core Animation、Core Image、SceneKit、SpriteKit 等等渲染框架都是构建于 Metal 之上的。</p>\n","abbrlink":"f75d2c59","categories":[{"name":"技术教程","path":"api/categories/技术教程.json"}],"tags":[{"name":"iOS","path":"api/tags/iOS.json"}]}