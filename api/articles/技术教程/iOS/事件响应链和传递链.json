{"title":"事件响应链和传递链","slug":"技术教程/iOS/事件响应链和传递链","date":"2022-02-02T03:18:00.000Z","updated":"2023-08-10T16:08:13.060Z","comments":false,"path":"api/articles/技术教程/iOS/事件响应链和传递链.json","excerpt":null,"covers":["/posts/346aa2fd/ResponderChains.png"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>iOS的事件由事件的响应链和传递链构成；先通过传递链传递下去，找到可以响应的UIResponse。</p>\n<p>传递链：由系统向最上层的view传递，Application -&gt; window -&gt; root view -&gt; … -&gt; first view </p>\n<p>响应链：由最上层的view向系统传递，first view -&gt; super view -&gt; … -&gt; view controller -&gt; window -&gt; Application -&gt; AppDelegate</p>\n<h2 id=\"事件传递链传递流程\"><a href=\"#事件传递链传递流程\" class=\"headerlink\" title=\"事件传递链传递流程\"></a>事件传递链传递流程</h2><p>1、用户点击屏幕：系统检测到手指触摸操作时，系统会将这个事件打包成一个UIEvent对象加入到Application的事件队列（为什么是事件队列？先进先出）；</p>\n<p>2、UIApplication会从事件队列中依次取出事件，传递给UIWindow；</p>\n<p>3、UIWindow对象会调用<code>hitTest:withEvent:</code>方法查找触摸操作所在的view；</p>\n<h3 id=\"hitTest-withEvent方法处理流程\"><a href=\"#hitTest-withEvent方法处理流程\" class=\"headerlink\" title=\"hitTest:withEvent方法处理流程\"></a><code>hitTest:withEvent</code>方法处理流程</h3><p>1、首先调用当前试图的<code>pointInside:withEvent:</code>方法判断触摸点是否在当前视图内；</p>\n<p>2、若返回NO，<code>hitTest:withEvent:</code>此时会返回nil；</p>\n<p>3、若返回YES，向当前视图的所有子视图发送<code>hitTest:withEvent</code>消息，所有子视图遍历顺序是从最顶层到最底层，直到有子视图返回非空对象或者全部子视图遍历完成；遍历到每一个子控件后，会重复1、2、3三个步骤；</p>\n<p>4、若第一次有子视图返回非空对象，则<code>hitTest:withEvent</code>返回此对象，处理结束；</p>\n<p>5、若所有子视图都返回空，则<code>hitTest:withEvent</code>返回self。</p>\n<h3 id=\"hitTest-withEvent方法的底层实现\"><a href=\"#hitTest-withEvent方法的底层实现\" class=\"headerlink\" title=\"hitTest:withEvent方法的底层实现\"></a><code>hitTest:withEvent</code>方法的底层实现</h3><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {</span><br><span class=\"line\">    // 判断能否接收事件</span><br><span class=\"line\">         if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil; </span><br><span class=\"line\"></span><br><span class=\"line\">        // 判断当前触摸点是否在view上  </span><br><span class=\"line\">        if ([self pointInside:point withEvent:event] == NO) return nil;  // 不在view上</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从后往前遍历子控件数组 </span><br><span class=\"line\">        int count = (int)self.subviews.count; </span><br><span class=\"line\">        for (int i = count - 1; i &gt;= 0; i--) { </span><br><span class=\"line\">            UIView *childView = self.subviews[i]; </span><br><span class=\"line\">            CGPoint childP = [self convertPoint:point toView:childView]; </span><br><span class=\"line\">            UIView *fitView = [childView hitTest:childP withEvent:event]; </span><br><span class=\"line\">        // 找到最合适的view </span><br><span class=\"line\">            if (fitView) { </span><br><span class=\"line\">                return fitView; </span><br><span class=\"line\">            }</span><br><span class=\"line\">        } </span><br><span class=\"line\">        // 没有找到更合适的view，也就是没有比自己更合适的view </span><br><span class=\"line\">        return self;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span><br></pre></td></tr></tbody></table></figure>\n\n<p>判断下传入过来的点在不在方法调用者的坐标系上。返回YES表示触摸点在坐标系上，返回NO表示触摸点不在坐标系上。</p>\n<h3 id=\"拦截事件的处理\"><a href=\"#拦截事件的处理\" class=\"headerlink\" title=\"拦截事件的处理\"></a>拦截事件的处理</h3><p><code>hitTest:withEvent</code>可以返回事件最合适的view，可以重写<code>hitTest:withEvent</code>方法，返回指定的view作为最合适的view。</p>\n<h2 id=\"事件响应链传递流程\"><a href=\"#事件响应链传递流程\" class=\"headerlink\" title=\"事件响应链传递流程\"></a>事件响应链传递流程</h2><p>1、如果当前这个view是控制器的view，就传递给控制器；如果不是控制器的view，就传递给父控件；</p>\n<p>2、在视图层次结构的的最顶层，如果不能处理事件，那么就传递给UIWindow;</p>\n<p>3、如果UIWindow不能处理事件，那么就传递给UIApplication;</p>\n<p>4、如果UIApplication不能处理事件，那么就会丢弃该次事件。</p>\n<p><img src=\"/posts/346aa2fd/ResponderChains.png\"></p>\n","more":"<p>iOS的事件由事件的响应链和传递链构成；先通过传递链传递下去，找到可以响应的UIResponse。</p>\n<p>传递链：由系统向最上层的view传递，Application -&gt; window -&gt; root view -&gt; … -&gt; first view </p>\n<p>响应链：由最上层的view向系统传递，first view -&gt; super view -&gt; … -&gt; view controller -&gt; window -&gt; Application -&gt; AppDelegate</p>\n<h2 id=\"事件传递链传递流程\"><a href=\"#事件传递链传递流程\" class=\"headerlink\" title=\"事件传递链传递流程\"></a>事件传递链传递流程</h2><p>1、用户点击屏幕：系统检测到手指触摸操作时，系统会将这个事件打包成一个UIEvent对象加入到Application的事件队列（为什么是事件队列？先进先出）；</p>\n<p>2、UIApplication会从事件队列中依次取出事件，传递给UIWindow；</p>\n<p>3、UIWindow对象会调用<code>hitTest:withEvent:</code>方法查找触摸操作所在的view；</p>\n<h3 id=\"hitTest-withEvent方法处理流程\"><a href=\"#hitTest-withEvent方法处理流程\" class=\"headerlink\" title=\"hitTest:withEvent方法处理流程\"></a><code>hitTest:withEvent</code>方法处理流程</h3><p>1、首先调用当前试图的<code>pointInside:withEvent:</code>方法判断触摸点是否在当前视图内；</p>\n<p>2、若返回NO，<code>hitTest:withEvent:</code>此时会返回nil；</p>\n<p>3、若返回YES，向当前视图的所有子视图发送<code>hitTest:withEvent</code>消息，所有子视图遍历顺序是从最顶层到最底层，直到有子视图返回非空对象或者全部子视图遍历完成；遍历到每一个子控件后，会重复1、2、3三个步骤；</p>\n<p>4、若第一次有子视图返回非空对象，则<code>hitTest:withEvent</code>返回此对象，处理结束；</p>\n<p>5、若所有子视图都返回空，则<code>hitTest:withEvent</code>返回self。</p>\n<h3 id=\"hitTest-withEvent方法的底层实现\"><a href=\"#hitTest-withEvent方法的底层实现\" class=\"headerlink\" title=\"hitTest:withEvent方法的底层实现\"></a><code>hitTest:withEvent</code>方法的底层实现</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class=\"line\">    // 判断能否接收事件</span><br><span class=\"line\">         if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil; </span><br><span class=\"line\"></span><br><span class=\"line\">        // 判断当前触摸点是否在view上  </span><br><span class=\"line\">        if ([self pointInside:point withEvent:event] == NO) return nil;  // 不在view上</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从后往前遍历子控件数组 </span><br><span class=\"line\">        int count = (int)self.subviews.count; </span><br><span class=\"line\">        for (int i = count - 1; i &gt;= 0; i--) &#123; </span><br><span class=\"line\">            UIView *childView = self.subviews[i]; </span><br><span class=\"line\">            CGPoint childP = [self convertPoint:point toView:childView]; </span><br><span class=\"line\">            UIView *fitView = [childView hitTest:childP withEvent:event]; </span><br><span class=\"line\">        // 找到最合适的view </span><br><span class=\"line\">            if (fitView) &#123; </span><br><span class=\"line\">                return fitView; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        // 没有找到更合适的view，也就是没有比自己更合适的view </span><br><span class=\"line\">        return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span><br></pre></td></tr></table></figure>\n\n<p>判断下传入过来的点在不在方法调用者的坐标系上。返回YES表示触摸点在坐标系上，返回NO表示触摸点不在坐标系上。</p>\n<h3 id=\"拦截事件的处理\"><a href=\"#拦截事件的处理\" class=\"headerlink\" title=\"拦截事件的处理\"></a>拦截事件的处理</h3><p><code>hitTest:withEvent</code>可以返回事件最合适的view，可以重写<code>hitTest:withEvent</code>方法，返回指定的view作为最合适的view。</p>\n<h2 id=\"事件响应链传递流程\"><a href=\"#事件响应链传递流程\" class=\"headerlink\" title=\"事件响应链传递流程\"></a>事件响应链传递流程</h2><p>1、如果当前这个view是控制器的view，就传递给控制器；如果不是控制器的view，就传递给父控件；</p>\n<p>2、在视图层次结构的的最顶层，如果不能处理事件，那么就传递给UIWindow;</p>\n<p>3、如果UIWindow不能处理事件，那么就传递给UIApplication;</p>\n<p>4、如果UIApplication不能处理事件，那么就会丢弃该次事件。</p>\n<p><img src=\"/posts/346aa2fd/ResponderChains.png\"></p>\n","categories":[{"name":"技术教程","path":"api/categories/技术教程.json"}],"tags":[{"name":"iOS","path":"api/tags/iOS.json"}]}