{"title":"离屏渲染","slug":"技术教程/iOS/离屏渲染","date":"2022-02-03T03:08:02.000Z","updated":"2023-05-05T14:55:02.755Z","comments":false,"path":"api/articles/技术教程/iOS/离屏渲染.json","excerpt":null,"covers":["/posts/59c46129/App.png","/posts/59c46129/OffscreenBuffer.png"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>正常的渲染流程：<br>￼<br><img src=\"/posts/59c46129/App.png\"></p>\n<p>App通过CPU与GPU的合作，不停的将渲染完成的内容放入Framebuffer帧缓冲区中，显示屏不断的从Framebuffer中获取内容并实时显示；</p>\n<p>离屏渲染的流程：<br>￼<br><img src=\"/posts/59c46129/OffscreenBuffer.png\"></p>\n<p>离屏渲染需要先额外创建离屏渲染缓冲区Offscreen Buffer，将渲染好的内容放入Offscreen Buffer，等离屏渲染完成后切换到Frame buffer中；</p>\n<h2 id=\"在Open-GL中，GPU有两种渲染方式\"><a href=\"#在Open-GL中，GPU有两种渲染方式\" class=\"headerlink\" title=\"在Open GL中，GPU有两种渲染方式\"></a>在Open GL中，GPU有两种渲染方式</h2><p>1、On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作；</p>\n<p>2、Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作；</p>\n<h2 id=\"离屏渲染消耗性能原因\"><a href=\"#离屏渲染消耗性能原因\" class=\"headerlink\" title=\"离屏渲染消耗性能原因\"></a>离屏渲染消耗性能原因</h2><p>1、需要创建新的缓冲区，大量的离屏渲染能导致内存压力过大；</p>\n<p>2、离屏渲染的整个流程，需要多次切换上下文环境，从当前屏幕切换到离屏，等离屏渲染完成后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕；</p>\n<h2 id=\"为什么会有离屏渲染\"><a href=\"#为什么会有离屏渲染\" class=\"headerlink\" title=\"为什么会有离屏渲染\"></a>为什么会有离屏渲染</h2><p>比如阴影、圆角等是由系统触发的。</p>\n<h2 id=\"常见离屏渲染场景\"><a href=\"#常见离屏渲染场景\" class=\"headerlink\" title=\"常见离屏渲染场景\"></a>常见离屏渲染场景</h2><p>1、光栅化<br>￼</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.shouldRasterize = YES;</span><br></pre></td></tr></tbody></table></figure>\n<p>2、mask</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CALayer *ly = [CALayer layer];</span><br><span class=\"line\">ly.frame = CGRectMake(0,0,380,200);</span><br><span class=\"line\">view.alyer.mask = ly;</span><br></pre></td></tr></tbody></table></figure>\n<p>￼<br>3、设置圆角同时，设置masksToBouns</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.cornerRadius = 10;</span><br><span class=\"line\">view.layer.masksToBounds = YES;</span><br></pre></td></tr></tbody></table></figure>\n<p>￼<br>可以通过CoreGraphics绘制圆角或者美工提供圆角图片。</p>\n<p>4、阴影的不透明度</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.shadowOpactity = 0.1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果同时设置showPath，不会造成离屏渲染</span><br><span class=\"line\">CGPathRef ref = CGPathCreateWithRoundedRect(view.bounds, 1, 1, NULL);</span><br><span class=\"line\">view.layer.shadowPath = ref;</span><br></pre></td></tr></tbody></table></figure>\n<p>￼<br>5、opacity<br>￼</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// opacity = 1, 不透明</span><br><span class=\"line\">// opacity = 0, 透明</span><br><span class=\"line\">// opacity = (0, 1), 造成离屏渲染</span><br><span class=\"line\">view.layer.opacity = 0.1;</span><br></pre></td></tr></tbody></table></figure>\n<h2 id=\"离屏渲染的逻辑\"><a href=\"#离屏渲染的逻辑\" class=\"headerlink\" title=\"离屏渲染的逻辑\"></a>离屏渲染的逻辑</h2><p>重写drawRect:方法并不会触发离屏渲染。</p>\n<p>图层的叠加绘制遵循“画家算法”，在这种算法下会按层绘制，首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分。</p>\n","more":"<p>正常的渲染流程：<br>￼<br><img src=\"/posts/59c46129/App.png\"></p>\n<p>App通过CPU与GPU的合作，不停的将渲染完成的内容放入Framebuffer帧缓冲区中，显示屏不断的从Framebuffer中获取内容并实时显示；</p>\n<p>离屏渲染的流程：<br>￼<br><img src=\"/posts/59c46129/OffscreenBuffer.png\"></p>\n<p>离屏渲染需要先额外创建离屏渲染缓冲区Offscreen Buffer，将渲染好的内容放入Offscreen Buffer，等离屏渲染完成后切换到Frame buffer中；</p>\n<h2 id=\"在Open-GL中，GPU有两种渲染方式\"><a href=\"#在Open-GL中，GPU有两种渲染方式\" class=\"headerlink\" title=\"在Open GL中，GPU有两种渲染方式\"></a>在Open GL中，GPU有两种渲染方式</h2><p>1、On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作；</p>\n<p>2、Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作；</p>\n<h2 id=\"离屏渲染消耗性能原因\"><a href=\"#离屏渲染消耗性能原因\" class=\"headerlink\" title=\"离屏渲染消耗性能原因\"></a>离屏渲染消耗性能原因</h2><p>1、需要创建新的缓冲区，大量的离屏渲染能导致内存压力过大；</p>\n<p>2、离屏渲染的整个流程，需要多次切换上下文环境，从当前屏幕切换到离屏，等离屏渲染完成后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕；</p>\n<h2 id=\"为什么会有离屏渲染\"><a href=\"#为什么会有离屏渲染\" class=\"headerlink\" title=\"为什么会有离屏渲染\"></a>为什么会有离屏渲染</h2><p>比如阴影、圆角等是由系统触发的。</p>\n<h2 id=\"常见离屏渲染场景\"><a href=\"#常见离屏渲染场景\" class=\"headerlink\" title=\"常见离屏渲染场景\"></a>常见离屏渲染场景</h2><p>1、光栅化<br>￼</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.shouldRasterize = YES;</span><br></pre></td></tr></table></figure>\n<p>2、mask</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CALayer *ly = [CALayer layer];</span><br><span class=\"line\">ly.frame = CGRectMake(0,0,380,200);</span><br><span class=\"line\">view.alyer.mask = ly;</span><br></pre></td></tr></table></figure>\n<p>￼<br>3、设置圆角同时，设置masksToBouns</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.cornerRadius = 10;</span><br><span class=\"line\">view.layer.masksToBounds = YES;</span><br></pre></td></tr></table></figure>\n<p>￼<br>可以通过CoreGraphics绘制圆角或者美工提供圆角图片。</p>\n<p>4、阴影的不透明度</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.shadowOpactity = 0.1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果同时设置showPath，不会造成离屏渲染</span><br><span class=\"line\">CGPathRef ref = CGPathCreateWithRoundedRect(view.bounds, 1, 1, NULL);</span><br><span class=\"line\">view.layer.shadowPath = ref;</span><br></pre></td></tr></table></figure>\n<p>￼<br>5、opacity<br>￼</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// opacity = 1, 不透明</span><br><span class=\"line\">// opacity = 0, 透明</span><br><span class=\"line\">// opacity = (0, 1), 造成离屏渲染</span><br><span class=\"line\">view.layer.opacity = 0.1;</span><br></pre></td></tr></table></figure>\n<h2 id=\"离屏渲染的逻辑\"><a href=\"#离屏渲染的逻辑\" class=\"headerlink\" title=\"离屏渲染的逻辑\"></a>离屏渲染的逻辑</h2><p>重写drawRect:方法并不会触发离屏渲染。</p>\n<p>图层的叠加绘制遵循“画家算法”，在这种算法下会按层绘制，首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分。</p>\n","abbrlink":"59c46129","categories":[{"name":"技术教程","path":"api/categories/技术教程.json"}],"tags":[{"name":"iOS","path":"api/tags/iOS.json"}]}