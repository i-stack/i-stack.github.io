{"title":"渲染原理","slug":"技术教程/iOS/渲染原理","date":"2022-01-03T02:49:58.000Z","updated":"2023-05-05T14:55:02.791Z","comments":false,"path":"api/articles/技术教程/iOS/渲染原理.json","excerpt":null,"covers":["/posts/a6d18922/Application.png","/posts/a6d18922/BUS.png"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"CPU-Central-Processing-Unit\"><a href=\"#CPU-Central-Processing-Unit\" class=\"headerlink\" title=\"CPU(Central Processing Unit)\"></a>CPU(Central Processing Unit)</h2><p>1、现代计算机整个系统的运算核心、控制核心；</p>\n<p>2、能处理大量不同的跳转、中断等指令；</p>\n<p>3、CPU 拥有更多的缓存空间 Cache 以及复杂的控制单元，计算能力并不是 CPU 的主要诉求；</p>\n<p>4、CPU 是设计目标是低时延，更多的高速缓存也意味着可以更快地访问数据；同时复杂的控制单元也能更快速地处理逻辑分支，更适合串行计算。</p>\n<h2 id=\"GPU-Graphics-Processing-Unit\"><a href=\"#GPU-Graphics-Processing-Unit\" class=\"headerlink\" title=\"GPU(Graphics Processing Unit)\"></a>GPU(Graphics Processing Unit)</h2><p>1、进行绘图运算工作的专用微处理器，是连接计算机和显示终端的纽带；</p>\n<p>2、适合大规模的并行计算。</p>\n<h2 id=\"图像渲染流水线\"><a href=\"#图像渲染流水线\" class=\"headerlink\" title=\"图像渲染流水线\"></a>图像渲染流水线</h2><p><img src=\"/posts/a6d18922/Application.png\"><br>￼</p>\n<h3 id=\"第一阶段：Application-应用处理阶段\"><a href=\"#第一阶段：Application-应用处理阶段\" class=\"headerlink\" title=\"第一阶段：Application 应用处理阶段\"></a>第一阶段：Application 应用处理阶段</h3><p>CUP对图像进行操作和改变得到图元，通常是三角形、线段、顶点等，然后将新的图像信息传递给下一阶段。</p>\n<h3 id=\"第二阶段：Geometry-几何处理阶段\"><a href=\"#第二阶段：Geometry-几何处理阶段\" class=\"headerlink\" title=\"第二阶段：Geometry 几何处理阶段\"></a>第二阶段：Geometry 几何处理阶段</h3><p>GPU处理上一阶段的图元信息，然后输出新的图元，这一阶段包括：</p>\n<p>1、顶点着色器(Vertex Shader)：这个阶段会将图元中的顶点信息进行视角转换、添加光照信息、增加纹理等操作；</p>\n<p>2、形状装配(Shape Assembly)：图元中的三角形、线段、点分别对应3个Vertex、2个Vertex、1Vertex，这个阶段会将Vertex连接成相应的形状；</p>\n<p>3、几何着色器(Geometry Shader)：通过三角形、线段、点构建更复杂的几何图形。</p>\n<h3 id=\"第三阶段：Rasterization光栅化阶段\"><a href=\"#第三阶段：Rasterization光栅化阶段\" class=\"headerlink\" title=\"第三阶段：Rasterization光栅化阶段\"></a>第三阶段：Rasterization光栅化阶段</h3><p>光栅化的主要目的是将几何渲染之后的图元信息转换为像素，用于后续显示在屏幕上。</p>\n<h3 id=\"第四阶段：Pixel-像素处理阶段\"><a href=\"#第四阶段：Pixel-像素处理阶段\" class=\"headerlink\" title=\"第四阶段：Pixel 像素处理阶段\"></a>第四阶段：Pixel 像素处理阶段</h3><p>经过光栅化阶段，得到了图元所对应的像素，给这些像素填充颜色和效果，最终显示在屏幕上。</p>\n<p>这些经过处理、蕴含大量信息的像素点集合，被称作位图(bitmap)，存在帧缓冲区(Framebuffer)中。</p>\n<p>1、片段着色器(Fragment Shader)：也叫Pixel Shader，目的是给每一个像素赋予正确的颜色，这些颜色的来源就是之前得到的顶点、纹理、光照等信息。由于需要处理纹理、光照等复杂信息，这部分是整个系统的性能瓶颈。</p>\n<p>2、测试与混合(Tests and Blending)：也叫Merging阶段，这个阶段主要处理片段的前后位置以及透明度。</p>\n<p>检测各个着色片段的深度值z坐标，从而判断片段的前后位置，计算相应的透明度 alpha 值，从而进行片段的混合，得到最终的颜色。</p>\n<p>GUP最后一步渲染结束之后的像素信息，被存在帧缓冲器（Frame Buffer）中。</p>\n<h2 id=\"屏幕成像\"><a href=\"#屏幕成像\" class=\"headerlink\" title=\"屏幕成像\"></a>屏幕成像</h2><p>在图像渲染流程结束后，接下来就需要将得到的像素信息显示在物理屏幕上。</p>\n<p><img src=\"/posts/a6d18922/BUS.png\"><br>￼<br>当垂直同步信号 <code>Vsync</code> 到来时，显示器的电子束会从屏幕的左上角开始逐行扫描，屏幕上的每个点的图像信息都是视频控制器从帧缓冲区中进行读取，在屏幕上显示。</p>\n<p>当电子束完成一帧的扫描，将要从头开始扫描时，就会发出一个垂直同步信号，视频控制器接收到 <code>Vsync</code> 之后，会将帧缓冲区中的位图更新为下一帧。<br>￼<br>1、电子束扫描的过程中，屏幕就能呈现出对应的结果，每次整个屏幕被扫描完一次后，就相当于呈现了一帧完整的图像。</p>\n<p>2、屏幕不断地刷新，不停呈现新的帧，就能呈现出连续的影像。</p>\n<p>3、屏幕刷新的频率，就是帧率(Frame per Second，FPS)。对于 iOS 而言，app 应该尽量保证 60 FPS 才是最好的体验。</p>\n<h2 id=\"屏幕撕裂-Screen-Tearing\"><a href=\"#屏幕撕裂-Screen-Tearing\" class=\"headerlink\" title=\"屏幕撕裂 Screen Tearing\"></a>屏幕撕裂 <code>Screen Tearing</code></h2><p>CPU + GPU 的渲染流程是一个非常耗时的过程。如果在电子束开始扫描新的一帧时，位图还没有渲染好，而是在扫描到屏幕中间时才渲染完成，被放入帧缓冲器中，那么已扫描的部分就是上一帧的画面，而未扫描的部分则会显示新的一帧图像，这就造成屏幕撕裂。</p>\n<p>解决屏幕撕裂、提高显示效率的一个策略就是使用垂直同步信号与双缓冲机制。</p>\n<p>iOS 设备会使用 V-sync + Double Buffering 的策略，双缓冲机制会增加一个新的备用缓冲区(back buffer)。</p>\n<h2 id=\"垂直同步信号-V-sync-双缓冲机制-Double-Buffering\"><a href=\"#垂直同步信号-V-sync-双缓冲机制-Double-Buffering\" class=\"headerlink\" title=\"垂直同步信号 V-sync + 双缓冲机制 Double Buffering\"></a>垂直同步信号 <code>V-sync</code> + 双缓冲机制 <code>Double Buffering</code></h2><p><code>V-sync</code> 相当于给帧缓冲器加锁：当电子束完成一帧的扫描，将要从头开始扫描时，会发出一个V-sync，只有视频控制器接受到V-sync才会将帧缓冲器中的位图更新为下一帧，这样保证每次显示的都是同一帧的画面，避免屏幕撕裂。</p>\n<p>双缓冲器机制会增加一个备用缓冲器(back buffer)，渲染结果会原先保存在 <code>back buffer</code> 中，当视频控制器接受到 <code>V-sync</code> 时，会将 <code>back buffer</code> 中的内容置换到 <code>frame buffer</code> 中，此时就能保证置换操作几乎在一瞬间完成，置换操作实际上是交换了 <code>back buffer</code> 与 <code>frame buffer</code> 的内存地址。</p>\n<h2 id=\"掉帧-Jank\"><a href=\"#掉帧-Jank\" class=\"headerlink\" title=\"掉帧 Jank\"></a>掉帧 Jank</h2><p>垂直同步信号 + 双缓冲机制能够解决屏幕撕裂的问题，但是会引入新的问题：掉帧。</p>\n<p>如果在接受到 <code>V-sync</code> 时，CPU与GPU还没有渲染好新的位图，视频控制器就不会去置换 <code>frame buffer</code> 中的位图，这时屏幕就会重新扫描呈现出上一帧的画面，相当于两个周期显示了同样的画面，这就是掉帧。</p>\n<p>三缓冲 <code>Triple Buffering</code></p>\n<p>利用CPU与GPU闲置时间进行下一步渲染，并将渲染结果暂存新增的缓冲器中，达到减少掉帧的次数。</p>\n<p>1、CPU 和 GPU 渲染耗时过长，在垂直同步信号 Vsync到来时计算还未完成，导致掉帧；</p>\n<p>2、V-sync与双缓存的意义：强制同步屏幕刷新，以掉帧为代价解决屏幕撕裂的问题；</p>\n<p>3、三缓冲的意义：合理使用CUP、GPU渲染性能，减少掉帧次数。</p>\n","more":"<h2 id=\"CPU-Central-Processing-Unit\"><a href=\"#CPU-Central-Processing-Unit\" class=\"headerlink\" title=\"CPU(Central Processing Unit)\"></a>CPU(Central Processing Unit)</h2><p>1、现代计算机整个系统的运算核心、控制核心；</p>\n<p>2、能处理大量不同的跳转、中断等指令；</p>\n<p>3、CPU 拥有更多的缓存空间 Cache 以及复杂的控制单元，计算能力并不是 CPU 的主要诉求；</p>\n<p>4、CPU 是设计目标是低时延，更多的高速缓存也意味着可以更快地访问数据；同时复杂的控制单元也能更快速地处理逻辑分支，更适合串行计算。</p>\n<h2 id=\"GPU-Graphics-Processing-Unit\"><a href=\"#GPU-Graphics-Processing-Unit\" class=\"headerlink\" title=\"GPU(Graphics Processing Unit)\"></a>GPU(Graphics Processing Unit)</h2><p>1、进行绘图运算工作的专用微处理器，是连接计算机和显示终端的纽带；</p>\n<p>2、适合大规模的并行计算。</p>\n<h2 id=\"图像渲染流水线\"><a href=\"#图像渲染流水线\" class=\"headerlink\" title=\"图像渲染流水线\"></a>图像渲染流水线</h2><p><img src=\"/posts/a6d18922/Application.png\"><br>￼</p>\n<h3 id=\"第一阶段：Application-应用处理阶段\"><a href=\"#第一阶段：Application-应用处理阶段\" class=\"headerlink\" title=\"第一阶段：Application 应用处理阶段\"></a>第一阶段：Application 应用处理阶段</h3><p>CUP对图像进行操作和改变得到图元，通常是三角形、线段、顶点等，然后将新的图像信息传递给下一阶段。</p>\n<h3 id=\"第二阶段：Geometry-几何处理阶段\"><a href=\"#第二阶段：Geometry-几何处理阶段\" class=\"headerlink\" title=\"第二阶段：Geometry 几何处理阶段\"></a>第二阶段：Geometry 几何处理阶段</h3><p>GPU处理上一阶段的图元信息，然后输出新的图元，这一阶段包括：</p>\n<p>1、顶点着色器(Vertex Shader)：这个阶段会将图元中的顶点信息进行视角转换、添加光照信息、增加纹理等操作；</p>\n<p>2、形状装配(Shape Assembly)：图元中的三角形、线段、点分别对应3个Vertex、2个Vertex、1Vertex，这个阶段会将Vertex连接成相应的形状；</p>\n<p>3、几何着色器(Geometry Shader)：通过三角形、线段、点构建更复杂的几何图形。</p>\n<h3 id=\"第三阶段：Rasterization光栅化阶段\"><a href=\"#第三阶段：Rasterization光栅化阶段\" class=\"headerlink\" title=\"第三阶段：Rasterization光栅化阶段\"></a>第三阶段：Rasterization光栅化阶段</h3><p>光栅化的主要目的是将几何渲染之后的图元信息转换为像素，用于后续显示在屏幕上。</p>\n<h3 id=\"第四阶段：Pixel-像素处理阶段\"><a href=\"#第四阶段：Pixel-像素处理阶段\" class=\"headerlink\" title=\"第四阶段：Pixel 像素处理阶段\"></a>第四阶段：Pixel 像素处理阶段</h3><p>经过光栅化阶段，得到了图元所对应的像素，给这些像素填充颜色和效果，最终显示在屏幕上。</p>\n<p>这些经过处理、蕴含大量信息的像素点集合，被称作位图(bitmap)，存在帧缓冲区(Framebuffer)中。</p>\n<p>1、片段着色器(Fragment Shader)：也叫Pixel Shader，目的是给每一个像素赋予正确的颜色，这些颜色的来源就是之前得到的顶点、纹理、光照等信息。由于需要处理纹理、光照等复杂信息，这部分是整个系统的性能瓶颈。</p>\n<p>2、测试与混合(Tests and Blending)：也叫Merging阶段，这个阶段主要处理片段的前后位置以及透明度。</p>\n<p>检测各个着色片段的深度值z坐标，从而判断片段的前后位置，计算相应的透明度 alpha 值，从而进行片段的混合，得到最终的颜色。</p>\n<p>GUP最后一步渲染结束之后的像素信息，被存在帧缓冲器（Frame Buffer）中。</p>\n<h2 id=\"屏幕成像\"><a href=\"#屏幕成像\" class=\"headerlink\" title=\"屏幕成像\"></a>屏幕成像</h2><p>在图像渲染流程结束后，接下来就需要将得到的像素信息显示在物理屏幕上。</p>\n<p><img src=\"/posts/a6d18922/BUS.png\"><br>￼<br>当垂直同步信号 <code>Vsync</code> 到来时，显示器的电子束会从屏幕的左上角开始逐行扫描，屏幕上的每个点的图像信息都是视频控制器从帧缓冲区中进行读取，在屏幕上显示。</p>\n<p>当电子束完成一帧的扫描，将要从头开始扫描时，就会发出一个垂直同步信号，视频控制器接收到 <code>Vsync</code> 之后，会将帧缓冲区中的位图更新为下一帧。<br>￼<br>1、电子束扫描的过程中，屏幕就能呈现出对应的结果，每次整个屏幕被扫描完一次后，就相当于呈现了一帧完整的图像。</p>\n<p>2、屏幕不断地刷新，不停呈现新的帧，就能呈现出连续的影像。</p>\n<p>3、屏幕刷新的频率，就是帧率(Frame per Second，FPS)。对于 iOS 而言，app 应该尽量保证 60 FPS 才是最好的体验。</p>\n<h2 id=\"屏幕撕裂-Screen-Tearing\"><a href=\"#屏幕撕裂-Screen-Tearing\" class=\"headerlink\" title=\"屏幕撕裂 Screen Tearing\"></a>屏幕撕裂 <code>Screen Tearing</code></h2><p>CPU + GPU 的渲染流程是一个非常耗时的过程。如果在电子束开始扫描新的一帧时，位图还没有渲染好，而是在扫描到屏幕中间时才渲染完成，被放入帧缓冲器中，那么已扫描的部分就是上一帧的画面，而未扫描的部分则会显示新的一帧图像，这就造成屏幕撕裂。</p>\n<p>解决屏幕撕裂、提高显示效率的一个策略就是使用垂直同步信号与双缓冲机制。</p>\n<p>iOS 设备会使用 V-sync + Double Buffering 的策略，双缓冲机制会增加一个新的备用缓冲区(back buffer)。</p>\n<h2 id=\"垂直同步信号-V-sync-双缓冲机制-Double-Buffering\"><a href=\"#垂直同步信号-V-sync-双缓冲机制-Double-Buffering\" class=\"headerlink\" title=\"垂直同步信号 V-sync + 双缓冲机制 Double Buffering\"></a>垂直同步信号 <code>V-sync</code> + 双缓冲机制 <code>Double Buffering</code></h2><p><code>V-sync</code> 相当于给帧缓冲器加锁：当电子束完成一帧的扫描，将要从头开始扫描时，会发出一个V-sync，只有视频控制器接受到V-sync才会将帧缓冲器中的位图更新为下一帧，这样保证每次显示的都是同一帧的画面，避免屏幕撕裂。</p>\n<p>双缓冲器机制会增加一个备用缓冲器(back buffer)，渲染结果会原先保存在 <code>back buffer</code> 中，当视频控制器接受到 <code>V-sync</code> 时，会将 <code>back buffer</code> 中的内容置换到 <code>frame buffer</code> 中，此时就能保证置换操作几乎在一瞬间完成，置换操作实际上是交换了 <code>back buffer</code> 与 <code>frame buffer</code> 的内存地址。</p>\n<h2 id=\"掉帧-Jank\"><a href=\"#掉帧-Jank\" class=\"headerlink\" title=\"掉帧 Jank\"></a>掉帧 Jank</h2><p>垂直同步信号 + 双缓冲机制能够解决屏幕撕裂的问题，但是会引入新的问题：掉帧。</p>\n<p>如果在接受到 <code>V-sync</code> 时，CPU与GPU还没有渲染好新的位图，视频控制器就不会去置换 <code>frame buffer</code> 中的位图，这时屏幕就会重新扫描呈现出上一帧的画面，相当于两个周期显示了同样的画面，这就是掉帧。</p>\n<p>三缓冲 <code>Triple Buffering</code></p>\n<p>利用CPU与GPU闲置时间进行下一步渲染，并将渲染结果暂存新增的缓冲器中，达到减少掉帧的次数。</p>\n<p>1、CPU 和 GPU 渲染耗时过长，在垂直同步信号 Vsync到来时计算还未完成，导致掉帧；</p>\n<p>2、V-sync与双缓存的意义：强制同步屏幕刷新，以掉帧为代价解决屏幕撕裂的问题；</p>\n<p>3、三缓冲的意义：合理使用CUP、GPU渲染性能，减少掉帧次数。</p>\n","abbrlink":"a6d18922","categories":[{"name":"技术教程","path":"api/categories/技术教程.json"}],"tags":[{"name":"iOS","path":"api/tags/iOS.json"}]}